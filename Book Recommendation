
# ----------------------------------------------------------------------------------
# --------------------- Data Preparation -------------------------------------------
# ----------------------------------------------------------------------------------

import pandas as pd
from collections import defaultdict

# process  ratings dataset 
df = pd.read_csv('Ratings.csv', sep=';', names=['UserID', 'ISBN', 'Rating'], skiprows=1)

# Create sequential ID mappings 
user_dict = {old: new+1 for new, old in enumerate(df['UserID'].unique())}
book_dict = {old: new+1 for new, old in enumerate(df['ISBN'].unique())}

# Store user ratings in  nested dictionary
ratings_dict = defaultdict(dict)

# Process each rating entry
for index, row in df.iterrows():
    mapped_user = user_dict[row['UserID']]
    mapped_book = book_dict[row['ISBN']]
    ratings_dict[mapped_user][mapped_book] = row['Rating']

# Generate output file
with open('ratings.libsvm', 'w') as output_file:
    for user in sorted(ratings_dict.keys()):
        # Format each rating as 'bookid:rating'
        formatted_ratings = [f'{book}:{rating}' 
                           for book, rating in sorted(ratings_dict[user].items())]
        # Write space-separated ratings for each user
        output_file.write(' '.join(formatted_ratings) + '\n')

print("created ratinsgs.libsvm")


# ----------------------------------------------------------------
# ---------------- Book Recomendation ----------------------------
# ----------------------------------------------------------------

import math
import gc
from multiprocessing import Pool
from collections import defaultdict

def load_libsvm(filename):
    """
    Building a dictionary of dictionaries to store the users along with their books & ratings as key value pairs
    """
    user_data = defaultdict(dict)
    with open(filename, 'r') as f:
        for user_id, line in enumerate(f, start=1):
            ratings = line.strip().split()
            for rating in ratings:
                book_id, score = map(float, rating.split(':'))
                user_data[user_id][int(book_id)] = score
    return user_data

def build_book_dict(user_data):
    """
    Build a dictionary where each book maps to a list of (user, rating) tuples.
    """
    book_dict = defaultdict(list)
    for user_id, books in user_data.items():
        for book_id, rating in books.items():
            book_dict[book_id].append((user_id, rating))
    return book_dict

def calculate_cosine_similarity(user1_ratings, user2_ratings):
    """
    Calculate cosine similarity between two users based on their ratings.
    """
    magnitude_user1 = math.sqrt(sum(rating**2 for rating in user1_ratings.values()))
    magnitude_user2 = math.sqrt(sum(rating**2 for rating in user2_ratings.values()))
    if magnitude_user1 == 0 or magnitude_user2 == 0:
        return 0
    else:
        dot_product = sum(user1_ratings[book] * user2_ratings[book] for book in user1_ratings if book in user2_ratings)
    return dot_product / (magnitude_user1 * magnitude_user2)

def find_similar_users(user_id, user_data, book_dict, top_n=10):
    """
    Find the top N most similar users to the target user using the book dictionary.
    """
    
    # Identify Candidate Users who have read similar books to the target user (refering to the books dictionary for easy access)
    candidate_users = set()
    for book in user_data[user_id]:
        if book in book_dict:
            candidate_users.update(book_dict[book].keys())
    candidate_users.discard(user_id)
    
    # Calculate cosine similarity for each candidate user => user_id: similarity_score
    similarities = {}
    # Only proceed if candidate_users is not empty
    if candidate_users:
        for user in candidate_users:
            similarity = calculate_cosine_similarity(user_ratings, user_data[other_user])
            similarities[other_user] = similarity
    
    # Return top N similar users
    return sorted(similarities.items(), key=lambda x: x[1], reverse=True)[:top_n]

def recommend_books(target_user, user_data, top_similar_users, top_n=5):
    """
    Recommend books for the target user based on top similar users.
    """
    
    # Retrieves the books the target user has already rated to avoid recommending them again
    target_ratings = user_data[target_user]
    
    candidate_books = defaultdict(float)
    similarity_sums = defaultdict(float)
    
    # Aggregate ratings for each book that the candidate (similar users) users have read
    for similar_user, similarity in top_similar_users:
        for book, rating in user_data[similar_user].items():
            if book not in target_ratings:  # Only consider books the target user hasn't rated
                candidate_books[book] += rating * similarity
                similarity_sums[book] += similarity
    
    # Calculate recommendation scores for each book that the target user will be potentially recommended and has not read the book himself
    recommendations = {
        book: candidate_books[book] / similarity_sums[book]
        for book in candidate_books if similarity_sums[book] > 0
    }
    
    # Return top N recommendations
    return sorted(recommendations.items(), key=lambda x: x[1], reverse=True)[:top_n]

# function to generate recommendations and run the code
def generate_recommendations(user_data, output_file, top_n=5):
    """
    Generate recommendations for all users and save them to a file.
    """
    book_dict = build_book_dict(user_data)

    batch_buffer = []
    with open(output_file, 'w') as f:
        for user_id in user_data.keys():
            top_similar_users = find_similar_users(user_id, user_data, book_dict)
            recommendations = recommend_books(user_id, user_data, top_similar_users, top_n)
            recommendation_str = ', '.join(f'BookID:{book}, Score:{score:.2f}' for book, score in recommendations)
            f.write(f'UserID:{user_id} -> {recommendation_str}\n')
                        # Add to batch buffer
            batch_buffer.append(f'UserID:{user_id} -> {recommendation_str}\n')
            
            # Write to file when batch is full
            if (idx + 1) % batch_size == 0:
                f.writelines(batch_buffer)
                batch_buffer = []  # Clear the buffer
    del book_dict  # Remove book_dict from memory
    del user_data
    gc.collect()   # Force garbage collection


user_data = load_libsvm('ratings.libsvm')
generate_recommendations(user_data, 'recommendations.csv')


# ----------------------------------------------------------------
# -- Book Recomendation according to the required format-----------
# ----------------------------------------------------------------


import math
from collections import defaultdict
from tqdm import tqdm

def load_data():
    """Load and preprocess data"""
    print("Loading books data...")
    # Create ISBN to title mapping from Books.csv
    isbn_to_title = {}
    book_id_to_isbn = {}
    
    with open('Books.csv', 'r', encoding='utf-8') as f:
        next(f)  # Skip header
        for idx, line in enumerate(f, start=1):
            try:
                parts = line.strip().split(';')
                isbn = parts[0].strip()
                title = parts[1].strip()
                isbn_to_title[isbn] = title
                book_id_to_isbn[idx] = isbn
            except:
                continue

    print("Loading ratings from libsvm...")
    ratings_dict = defaultdict(dict)
    with open('ratings.libsvm', 'r') as f:
        for user_id, line in enumerate(f, start=1):
            ratings = line.strip().split()
            for rating in ratings:
                book_id, score = map(float, rating.split(':'))
                ratings_dict[user_id][int(book_id)] = score

    # Precompute user norms
    print("Computing user norms...")
    user_norms = {
        user: math.sqrt(sum(rating * rating for rating in ratings.values()))
        for user, ratings in ratings_dict.items()
        if sum(rating * rating for rating in ratings.values()) > 0
    }

    return ratings_dict, isbn_to_title, user_norms, book_id_to_isbn

def calculate_similarity(user1, user2, ratings_dict, user_norms):
    """Calculate cosine similarity between two users"""
    if user1 not in user_norms or user2 not in user_norms:
        return 0.0
    
    common_books = set(ratings_dict[user1].keys()) & set(ratings_dict[user2].keys())
    if not common_books:
        return 0.0
    
    dot_product = sum(ratings_dict[user1][book] * ratings_dict[user2][book] for book in common_books)
    denominator = user_norms[user1] * user_norms[user2]
    
    return dot_product / denominator if denominator > 0 else 0.0

def get_recommendations(target_user, ratings_dict, user_norms, k=10):
    """Get top 5 book recommendations"""
    similarities = []
    for other_user in ratings_dict:
        if other_user != target_user:
            sim = calculate_similarity(target_user, other_user, ratings_dict, user_norms)
            if sim > 0:
                similarities.append((other_user, sim))
    
    similar_users = sorted(similarities, key=lambda x: x[1], reverse=True)[:k]
    if not similar_users:
        return []
    
    user_books = set(ratings_dict[target_user].keys())
    recommendations = {}
    
    for similar_user, sim in similar_users:
        for book in ratings_dict[similar_user]:
            if book not in user_books:
                numerator = sum(ratings_dict[sim_user][book] * sim 
                              for sim_user, sim in similar_users 
                              if book in ratings_dict[sim_user])
                denominator = sum(sim for _, sim in similar_users)
                if denominator > 0:
                    recommendations[book] = numerator / denominator
    
    return sorted(recommendations.items(), key=lambda x: x[1], reverse=True)[:5]

def main():
    # Load data and precompute norms
    ratings_dict, isbn_to_title, user_norms, book_id_to_isbn = load_data()
    
    print("Generating recommendations...")
    total_users = len(ratings_dict)
    
    with open('recommendations.csv', 'w', encoding='utf-8', newline='') as f:
        f.write('User_ID,Book_ID,Book_Title,Recommendation_Score\n')
        for user in tqdm(ratings_dict.keys(), total=total_users, desc="Processing users"):
            recommendations = get_recommendations(user, ratings_dict, user_norms)
            for book_id, score in recommendations:
                # Get book title, use book_id as fallback if not found
                title = isbn_to_title.get(book_id_to_isbn.get(book_id, str(book_id)), f"Book_{book_id}")
                scaled_score = min(max(round(score * 2), 1), 10)
                f.write(f'{user},{book_id},"{title}",{scaled_score}\n')

    print("Recommendations generated successfully!")

main()


